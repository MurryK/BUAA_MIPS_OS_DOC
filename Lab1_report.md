##实验思考题
###Thinking 1.1
ls –l : 使用长格式显示每个文件，包含文件的详细信息
mv test1.c test2.c : 将文件test1.c重命名为test2.c
cp test1.c test2.c : 将test1.c文件复制成为test2.c
cd .. 回到上一层目录
###Thinking 1.2
Grep是一种强大的匹配搜索工具，它可以通过正则表达式来匹配并且将匹配到的行号打印出来，基本的语法是grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]。常用的参数有几个比如 –a表示搜索二进制文件，-i表示忽略大小写，-n表示输出行号，-v表示反向选择，-r表示搜索目录下所有文件和子目录。
如果要查找本项目（在此以我的项目路径为例）中所有的宏，即可使用指令 grep -a -r -n -i '#define' /home/13005028/13005028-lab/*。
如果要找指定的函数名，在此以printf举例，即可使用命令 grep -a -r -n -i '\bprintf\s*(.*)' /home/13005028/13005028-lab/* 来查找这个以printf为名的函数。
###Thinking 1.3
如果在使用gcc指令编译时带上-werror参数编译，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改。-wall参数则会让编译器在编译过程中列出所有的警告信息，这两条参数在项目开发中的意义在于它可以让开发人员在编译过程中发现所有的潜在隐患并且及时的排除掉他们。如果同时使用，则很大程度上保证的项目的安全性并且加快开发的进度。还可以一定程度上减少后期维护的麻烦。
###Thinking 2.1
如果要恢复printf.c,只要使用 git checkout printf.c这个指令即可将文件从暂存区恢复回来，只要在暂存区的文件还没有被删除掉
如果文件在git中已经被通过rm指令删除掉了，则可以将文件恢复到历史版本，如果不想影响对其他文件的修改，则可以新建一个临时分支，然后通过git log指令查看历史纪录并且几下 hash-code，然后使用git reset –hard <hash-code>来讲历史版本恢复到临时分支中，然后可以单独将目标文件复制到目标地址来。
如果想要阻止已经被添加到缓存区的文件被commit到版本库中，可以使用git reset HEAD <file>指令来从缓存区删除文件。工作区的文件则不做出改变
###Thinking 2.2
克隆时只会在本地创建master分支(被HEAD指向的分支)，其余分支均不会被自动检出。但是如果想要其他分支可以单独使用checkout指令在本地创建一个分支并且自动与远程的同名分支 关联起来。Git status是显示当前git文件追踪以及修改状态，git log 显示历史文件的版本信息，git commit是将暂存区的文件移动到本地版本库，并不访问远程版本库。Git checkout指令在本地创建与远程分支同名的分支时会自动指向远程分支，所以算是会访问远程版本库。克隆后的默认分支不会处于master分支而是处于之前所在的分支
所以3是正确的，其余都是错误的。
依据如下：
![first](https://github.com/MurryK/BUAA_MIPS_OS_DOC/blob/master/4.jpg?raw=true)
![second](https://github.com/MurryK/BUAA_MIPS_OS_DOC/blob/master/4.png?raw=true)
![third](https://github.com/MurryK/BUAA_MIPS_OS_DOC/blob/master/5.png?raw=true)
 
参考依据来源于自己的实验结果，网络博客以及参考书《pro-git》.
##实验难点图示
我认为本次实验相对比较难的是printf函数的实现，在阅读了很久并且查阅了不少的相关材料之后才有所理解，printf函数的主要子函数包lp_Print函数，其主要实现过程如下:
![forth](https://github.com/MurryK/BUAA_MIPS_OS_DOC/blob/master/print.png?raw=true)
##体会与感想
第一次的操作系统实验还是比较简单的，并没有遇见太多的很难的地方，不过这其中大部分的原因还是因为我们有十分详尽和完备的实验指导书。其中大部分的练习题附近都会有很明显的暗示，所以有可能即使对一个问题没有理解的很透彻，跟着指导书的提示仍然能做出来。这就要求我们下去之后仍然需要自己去琢磨透彻其中的深层次原理。
总的来说收获还是十分巨大的，学到了很多的东西，例如对linux的掌握，对git的基本操作和工作原理的学习，还有系统级的代码的实现，让我自己的编程能力有所进一步的提升。同时也对操作系统形成了一个大概的认知，具体的细节后面的实验还是会加紧努力学习透彻
##指导书反馈
指导书十分的详尽，在做实验的过程中，有个一个小问题就是在运行内核的指令gxemul –E testmips –C R3000 –M 64 elf-file 前面应该改成./gxemul ,虽然现在看来是个很简单的问题，但是当时由于对linux系统可执行文件的运行方法不是很熟练，导致在这里耽误了很多的时间。
##残留难点
做完之后还是有不少的残留难点的，主要还是集中在对系统文件结构不是很理解，比如各个文件以及文件夹之间是什么关系，那些文件有哪些作用，对于这些东西的说明指导书里也不是很详尽。只能被动的被告知应该去哪里找哪个文件。而对对于系统级非.c文件也还是不太能读懂，可能是因为相关的练习比较少，涉及到的只有简单的修改路径或者根据已有的提示加上两行简单的mips指令。
